= Event Subscription API
team@openapitools.org
1.80.0
:toc: left
:numbered:
:toclevels: 3
:source-highlighter: highlightjs
:keywords: openapi, rest, Event Subscription API 
:specDir: 
:snippetDir: 
:generator-template: v1 2019-12-20
:info-url: https://openapi-generator.tech
:app-name: Event Subscription API

[abstract]
.Abstract
This REST API can be used to create, update, delete, or view event subscriptions.  Please click this link to enable Swagger to call the APIs.  Without this step, all attempts to try out the APIs will result in a 401 Not Authorized error.  


// markup not found, no include::{specDir}intro.adoc[opts=optional]



== Endpoints


[.Status]
=== Status


[.disableSubscriptionUsingPOST]
==== disableSubscriptionUsingPOST
    
`POST /api/v1/subscriptions/{id}/disable`

Manually disable the given subscription

===== Description 

Marks the webhook as disabled until the given end time. This will prevent published to the webhook. It will remain disabled until it is manually re-enabled or until the end time is reached. After 5 days of being disabled consecutively, we will stop saving unpublished payloads for the webhook. After 14 days of being disabled consecutively we will delete all subscriptions for that webhook.


// markup not found, no include::{specDir}api/v1/subscriptions/\{id\}/disable/POST/spec.adoc[opts=optional]



===== Parameters

====== Path Parameters

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| id 
| id  
| X 
| null 
|  

|===         




====== Query Parameters

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| endTime 
| endTime  
| - 
| null 
|  

|===         


===== Return Type

<<WebhookStatus>>


===== Content Type

* */*

===== Responses

.http response codes
[cols="2,3,1"]
|===         
| Code | Message | Datatype 


| 202
| Accepted
|  <<WebhookStatus>>


| 429
| Too Many Requests
|  <<RateLimitResponseModel>>

|===         

===== Samples


// markup not found, no include::{snippetDir}api/v1/subscriptions/\{id\}/disable/POST/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}api/v1/subscriptions/\{id\}/disable/POST/http-response.adoc[opts=optional]



// file not found, no * wiremock data link :api/v1/subscriptions/{id}/disable/POST/POST.json[]


ifdef::internal-generation[]
===== Implementation

// markup not found, no include::{specDir}api/v1/subscriptions/\{id\}/disable/POST/implementation.adoc[opts=optional]


endif::internal-generation[]


[.enableSubscriptionUsingPOST]
==== enableSubscriptionUsingPOST
    
`POST /api/v1/subscriptions/{id}/enable`

Manually enable the given subscription

===== Description 

Mark the given subscription's webhook as successful and enable it. This will return a 404 if no subscription with this ID is found or its webhook is not disabled. Note that if the webhook is experiencing problems then it may end up getting disabled again immediately.


// markup not found, no include::{specDir}api/v1/subscriptions/\{id\}/enable/POST/spec.adoc[opts=optional]



===== Parameters

====== Path Parameters

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| id 
| id  
| X 
| null 
|  

|===         






===== Return Type



-

===== Content Type

* */*

===== Responses

.http response codes
[cols="2,3,1"]
|===         
| Code | Message | Datatype 


| 202
| Accepted
|  <<>>


| 429
| Too Many Requests
|  <<RateLimitResponseModel>>

|===         

===== Samples


// markup not found, no include::{snippetDir}api/v1/subscriptions/\{id\}/enable/POST/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}api/v1/subscriptions/\{id\}/enable/POST/http-response.adoc[opts=optional]



// file not found, no * wiremock data link :api/v1/subscriptions/{id}/enable/POST/POST.json[]


ifdef::internal-generation[]
===== Implementation

// markup not found, no include::{specDir}api/v1/subscriptions/\{id\}/enable/POST/implementation.adoc[opts=optional]


endif::internal-generation[]


[.getSubscriptionStatusUsingGET]
==== getSubscriptionStatusUsingGET
    
`GET /api/v1/subscriptions/{id}/status`

Return the status of a subscription's webhook

===== Description 

Get the enable/disable status of a subscription's webhook. If a webhook consistently returns error responses or times out when the Platform tries to publish events to it then the webhook will accrue penalties and eventually be temporarily disabled. The Platform will NOT attempt to publish events to a webhook while it is disabled. The purpose of this feature is to prevent subscriptions with nonexistent or non-functional webhooks from consuming the Platform resources. This API returns the status of a subscription's webhook including whether it is currently disabled and when the Platform will automatically enable the webhook again.   The Platform keeps a record of events that went undelivered to a webhook due to the webhook timing out, returning an error, or being skipped because it was disabled. When the webhook is re-enabled (which happens once its disable status automatically expires and the Platform successfully publishes an event to it) the Platform will publish all undelivered events to the webhook from up to 5 days prior to the webhook first being disabled.   You can use the `api/v1/subscriptions/webhook/performTest` endpoint to assist you in debugging why your webhook has been disabled. See the documentation on that endpoint.   If a webhook has only returned error responses or timeouts for 14 consecutive days then all subscriptions using that webhook will be automatically deleted.


// markup not found, no include::{specDir}api/v1/subscriptions/\{id\}/status/GET/spec.adoc[opts=optional]



===== Parameters

====== Path Parameters

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| id 
| id  
| X 
| null 
|  

|===         






===== Return Type

<<WebhookStatus>>


===== Content Type

* application/json

===== Responses

.http response codes
[cols="2,3,1"]
|===         
| Code | Message | Datatype 


| 200
| OK
|  <<WebhookStatus>>


| 429
| Too Many Requests
|  <<RateLimitResponseModel>>

|===         

===== Samples


// markup not found, no include::{snippetDir}api/v1/subscriptions/\{id\}/status/GET/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}api/v1/subscriptions/\{id\}/status/GET/http-response.adoc[opts=optional]



// file not found, no * wiremock data link :api/v1/subscriptions/{id}/status/GET/GET.json[]


ifdef::internal-generation[]
===== Implementation

// markup not found, no include::{specDir}api/v1/subscriptions/\{id\}/status/GET/implementation.adoc[opts=optional]


endif::internal-generation[]


[.testWebhookUsingPOST]
==== testWebhookUsingPOST
    
`POST /api/v1/subscriptions/webhook/performTest`

Publish a test event to the webhook

===== Description 

This test simulates how the Platform publishes events to a webhook and can be used to debug problems with the webhook. A test event (the exact fields are provided below) is published to the url provided in the body of the request. If a shared secret is provided then we will also include the GTD-X-Signature header (see the Subscription API documentation for more details on how you can use the sharedSecret to verify that an event publish came from the Platform). We verify that the webhook meets the following two requirements: 1. The webhook returns a 2xx http response to confirm that it received the event. 2. The webhook responds within the timeout window which is 5 seconds. If a subscription's webhook does not follow these rules then it will eventually result in the Platform temporarily disabling the webhook, meaning the Platform will not try to publish events to the webhook for a period of time.   After conducting the test, this API will return a WebhookTestResult which contains the exact http body and headers the Platform sent to the webhook as well as the exact http response we received, if any. The field testResultDetails will contain additional information that can assist in debugging why the test failed. Some common problems are:   * Your webhook expects a single JSON object `{...eventdata...}` when the Platform actually publishes events as a JSON array `[{...eventData...}]`.   * Your webhook does a large amount of processing before returning a response. The Platform requires that your webhook return a success response within 5 seconds or we consider your webhook to have timed out and assume the event publish was not delivered. If you must do processing with the event that takes more than 5 seconds, then you should respond to the Platform *before* performing your processing.   * An event contained a field your webhook app didn't expect so it returned an exception. We are constantly adding new features to Tradelens which often involve new event types and new fields on existing events. (The most up-to-date list of every field that can be on an event and its type is maintained in the Trade Object API documentation under the model for the response value of any of the /events/ endpoints, for example `/api/v1/transportEquipment/events/{transportEquipmentId}/transportEquipmentId`.) Your webhook code should be able to handle unexpected fields gracefully.   * Your webhook doesn't accept https connections.    The exact POST body that will be sent to your webhook is: `[{\"eventSubmissionTime\":1579618098877,\"originatorId\":\"GTD-SIP\",\"originatorName\":\"GTD-SIP\",\"eventTransactionId\":\"a65d2295-5710-442a-b402-82732e02d97a\",\"eventType\":\"subscriptionTestEvent\",\"sentFromInternal\":false}]` Note that the eventSubmissionTime and eventTransactionId will vary with each test. The other fields will always have the same value.


// markup not found, no include::{specDir}api/v1/subscriptions/webhook/performTest/POST/spec.adoc[opts=optional]



===== Parameters


===== Body Parameter

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| Webhook 
| webhook <<Webhook>> 
| X 
|  
|  

|===         





===== Return Type

<<WebhookTestResult>>


===== Content Type

* application/json

===== Responses

.http response codes
[cols="2,3,1"]
|===         
| Code | Message | Datatype 


| 202
| Accepted
|  <<WebhookTestResult>>


| 429
| Too Many Requests
|  <<RateLimitResponseModel>>

|===         

===== Samples


// markup not found, no include::{snippetDir}api/v1/subscriptions/webhook/performTest/POST/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}api/v1/subscriptions/webhook/performTest/POST/http-response.adoc[opts=optional]



// file not found, no * wiremock data link :api/v1/subscriptions/webhook/performTest/POST/POST.json[]


ifdef::internal-generation[]
===== Implementation

// markup not found, no include::{specDir}api/v1/subscriptions/webhook/performTest/POST/implementation.adoc[opts=optional]


endif::internal-generation[]


[.Subscriptions]
=== Subscriptions


[.createCountryUsingPOST]
==== createCountryUsingPOST
    
`POST /api/v1/subscriptions/country`

Create a subscription using a country code

===== Description 

Configures a webhook for a country. The webhook will receive all events for all consignments and transport equipment that pass through that country.   The `uri` field is required.  An optional `sharedSecret` can be included that will be used to calculate the Hash-based Message Authentication Code(or HMAC) signature.  Our service currently supports the `HmacSHA256` algorithm (see http://www.ietf.org/rfc/rfc2104.txt).   Please note that we have shifted from SHA1 in the deprecated endpoints to SHA256 in these endpoints  The HMAC signature is the product of a hash function applied to the body of a message along with the `sharedSecret`. When Shipping Information Pipeline sends a subscriber an event, it stores the signature on the header named `X-GTD-Signature`.  When the subscriber's server receives the event, it uses the same `sharedSecret` to compute the same HMAC.  If the computed HMAC equals the value found in the header named `X-GTD-Signature` the request is authenticated. For the signatures to match, not only must the `sharedSecret` used at both ends of the transaction match, but the message body must also match exactly.  Below is a Java sample to validate the `X-GTD-Signature`. ~~~ String xGTDSignature = \"hashvaluefromheader\"; Mac hmac = Mac.getInstance(\"HmacSHA256\"); hmac.init(new SecretKeySpec(\"sharedSecretValue\".getBytes( Charset.forName(\"UTF-8\")), \"HmacSHA256\")); String calculatedSignature = Hex.encodeHexString(hmac.doFinal(event.getBytes(Charset.forName(\"UTF-8\")))); logger.debug(className+\"calculatedSignature: \"+calculatedSignature); if(xGTDSignature.equals(calculatedSignature)){     // signed body matched } ~~~ For more information see: * https://docs.oracle.com/javase/8/docs/api/javax/crypto/Mac.html * https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#Mac * http://www.ietf.org/rfc/rfc2104.txt  The webhook will receive arrays of events as the body of an HTTP POST request. The webhook must respond with an HTTP success code response. Webhooks that do not respond promptly (within 5 seconds) more than once over a period of time (one hour) will be disabled for a short duration (10 seconds after the second non-response, 1 hour on all subsequent non-responses), meaning the platform will not attempt to publish events to the webhook while it is disabled. A webhook will be instantly enabled if it responds one time within 5 seconds and the platform will send all the unpublished events at that time. If the webhook has not responded for 5 days, all unpublished events are discarded and any new events will not be saved. The webhook will still be instantly enabled if it responds within the required time.    Each event published to the webhook will contain all information originally published in the event, plus additional fields added during the processing of events for the convenience of associating events with the consignments and transport equipment to which they belong.  * If the event is on the level of a transport equipment, both the \"transportEquipmentId\" and \"equipmentNumber\" will be added to the event if they were not originally present. If the transport equipment was associated with any consignments at the time the event was sent to the webhook, then the \"associatedConsignmentIds\" field will be populated with the consignmentId of all those consignments.  * If the event was published to a consignment, the \"consignmentId\" associated with the consignment will be added to the event.  * All events are given an internal \"type\" field corresponding to the code of their type (e.g. \"E025\").  Here is an example.  ~~~ [     {         \"eventSubmissionTime\": 1523633968187,         \"type\": \"E021\",         \"originatorId\": \"origninatorId\",         \"eventOccurrenceTime\": 1523633968187,         \"originatorName\": \"originatorName\",         \"transportEquipmentId\": \"6c995b93-ddf8-4062-a519-99db31a111ef\",         \"equipmentNumber\": \"Test-V1-T003-1523633966168-C1\",         \"transportationPhase\": \"Transshipment\",         \"associatedConsignmentIds\": [\"ConsignmentId1\", \"ConsignmentId2\"],         \"location\": {             \"type\": \"UN/Locode\",             \"value\": \"NLRTM\"         }     }] ~~~ Filtering on Event Types:  * The event type and document type filters filter ON events. Only the events that match the filter definitions will be sent on the subscription. The list of valid event types can be found in the Query API: GET /api/v1/eventTypes. * ...EventTypes is an array of event types. These can be the full names of the events (e.g. \"plannedVesselArrival\") or the Exxx code (e.g. \"E310\")\". * docEventFilters is an array of action and document type pairs. If action is not specified, then document events whose document type matches the filter, regardless of their associated action, will be sent on the subscription. * To allow all document events to be sent on the subscription, just add \"documentEvents\" to the ...EventTypes array and do not specify docEventFilters.   The following examples are for an org subscription. Replace org with port or country in orgEventTypes if using port or country subscriptions: * To subscribe to PRO_FORMA_INVOICE submitted document events:   ~~~         \"docEventFilters\": [           {\"action\": \"submitted\",            \"docType\": \"PRO_FORMA_INVOICE\"}          ]  ~~~  * To subscribe to all document events:   ~~~         \"orgEventTypes\": [           \"documentEvents\"           ]  ~~~ * To subscribe to plannedVesselArrival and SHIPPING_INSTRUCTIONS submitted events:   ~~~         \"orgEventTypes\": [           \"plannedVesselArrival\"           ],          \"docEventFilters\": [           {\"action\": \"submitted\",            \"docType\": \"SHIPPING_INSTRUCTIONS\"}          ]  ~~~ 


// markup not found, no include::{specDir}api/v1/subscriptions/country/POST/spec.adoc[opts=optional]



===== Parameters


===== Body Parameter

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| CountrySubscription 
| countrySubscription <<CountrySubscription>> 
| X 
|  
|  

|===         





===== Return Type

<<MessageResponseV1>>


===== Content Type

* application/json

===== Responses

.http response codes
[cols="2,3,1"]
|===         
| Code | Message | Datatype 


| 202
| Accepted
|  <<MessageResponseV1>>


| 429
| Too Many Requests
|  <<RateLimitResponseModel>>

|===         

===== Samples


// markup not found, no include::{snippetDir}api/v1/subscriptions/country/POST/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}api/v1/subscriptions/country/POST/http-response.adoc[opts=optional]



// file not found, no * wiremock data link :api/v1/subscriptions/country/POST/POST.json[]


ifdef::internal-generation[]
===== Implementation

// markup not found, no include::{specDir}api/v1/subscriptions/country/POST/implementation.adoc[opts=optional]


endif::internal-generation[]


[.createOrgUsingPOST]
==== createOrgUsingPOST
    
`POST /api/v1/subscriptions/org`

Create a subscription for your organization

===== Description 

Configures a webhook for the organization with which the current user is authenticated. The webhook will receive all events for all consignments that are determined to be associated with the user's organization.    An organization becomes associated with a consignment or transport equipment in the following ways:  * A user sends a E001 event to add the organization to the given consignment. This adds the organization to both the consignment AND all transport equipment associated with the consignment.  * A user submits the Start Transport Equipment Tracking event. The organization for the user is automatically added to the transport equipment.  * A user submits the Start Consignment Tracking event. The organization for the user is automatically added to the consignment AND all transport equipment associated with the consignment.  The `uri` field is required.  An optional `sharedSecret` can be included that will be used to calculate the Hash-based Message Authentication Code(or HMAC) signature.  Our service currently supports the `HmacSHA256` algorithm (see http://www.ietf.org/rfc/rfc2104.txt).   Please note that we have shifted from SHA1 in the deprecated endpoints to SHA256 in these endpoints  The HMAC signature is the product of a hash function applied to the body of a message along with the `sharedSecret`. When Shipping Information Pipeline sends a subscriber an event, it stores the signature on the header named `X-GTD-Signature`.  When the subscriber's server receives the event, it uses the same `sharedSecret` to compute the same HMAC.  If the computed HMAC equals the value found in the header named `X-GTD-Signature` the request is authenticated. For the signatures to match, not only must the `sharedSecret` used at both ends of the transaction match, but the message body must also match exactly.  Below is a Java sample to validate the `X-GTD-Signature`. ~~~ String xGTDSignature = \"hashvaluefromheader\"; Mac hmac = Mac.getInstance(\"HmacSHA256\"); hmac.init(new SecretKeySpec(\"sharedSecretValue\".getBytes( Charset.forName(\"UTF-8\")), \"HmacSHA256\")); String calculatedSignature = Hex.encodeHexString(hmac.doFinal(event.getBytes(Charset.forName(\"UTF-8\")))); logger.debug(className+\"calculatedSignature: \"+calculatedSignature); if(xGTDSignature.equals(calculatedSignature)){     // signed body matched } ~~~ For more information see: * https://docs.oracle.com/javase/8/docs/api/javax/crypto/Mac.html * https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#Mac * http://www.ietf.org/rfc/rfc2104.txt  The webhook will receive arrays of events as the body of an HTTP POST request. The webhook must respond with an HTTP success code response. Webhooks that do not respond promptly (within 5 seconds) more than once over a period of time (one hour) will be disabled for a short duration (10 seconds after the second non-response, 1 hour on all subsequent non-responses), meaning the platform will not attempt to publish events to the webhook while it is disabled. A webhook will be instantly enabled if it responds one time within 5 seconds and the platform will send all the unpublished events at that time. If the webhook has not responded for 5 days, all unpublished events are discarded and any new events will not be saved. The webhook will still be instantly enabled if it responds within the required time.    Each event published to the webhook will contain all information originally published in the event, plus additional fields added during the processing of events for the convenience of associating events with the consignments and transport equipment to which they belong.  * If the event is on the level of a transport equipment, both the \"transportEquipmentId\" and \"equipmentNumber\" will be added to the event if they were not originally present. If the transport equipment was associated with any consignments at the time the event was sent to the webhook, then the \"associatedConsignmentIds\" field will be populated with the consignmentId of all those consignments.  * If the event was published to a consignment, the \"consignmentId\" associated with the consignment will be added to the event.  * All events are given an internal \"type\" field corresponding to the code of their type (e.g. \"E025\").  Here is an example.  ~~~ [     {         \"eventSubmissionTime\": 1523633968187,         \"type\": \"E021\",         \"originatorId\": \"origninatorId\",         \"eventOccurrenceTime\": 1523633968187,         \"originatorName\": \"originatorName\",         \"transportEquipmentId\": \"6c995b93-ddf8-4062-a519-99db31a111ef\",         \"equipmentNumber\": \"Test-V1-T003-1523633966168-C1\",         \"transportationPhase\": \"Transshipment\",         \"associatedConsignmentIds\": [\"ConsignmentId1\", \"ConsignmentId2\"],         \"location\": {             \"type\": \"UN/Locode\",             \"value\": \"NLRTM\"         }     }] ~~~ Filtering on Event Types:  * The event type and document type filters filter ON events. Only the events that match the filter definitions will be sent on the subscription. The list of valid event types can be found in the Query API: GET /api/v1/eventTypes. * ...EventTypes is an array of event types. These can be the full names of the events (e.g. \"plannedVesselArrival\") or the Exxx code (e.g. \"E310\")\". * docEventFilters is an array of action and document type pairs. If action is not specified, then document events whose document type matches the filter, regardless of their associated action, will be sent on the subscription. * To allow all document events to be sent on the subscription, just add \"documentEvents\" to the ...EventTypes array and do not specify docEventFilters.   The following examples are for an org subscription. Replace org with port or country in orgEventTypes if using port or country subscriptions: * To subscribe to PRO_FORMA_INVOICE submitted document events:   ~~~         \"docEventFilters\": [           {\"action\": \"submitted\",            \"docType\": \"PRO_FORMA_INVOICE\"}          ]  ~~~  * To subscribe to all document events:   ~~~         \"orgEventTypes\": [           \"documentEvents\"           ]  ~~~ * To subscribe to plannedVesselArrival and SHIPPING_INSTRUCTIONS submitted events:   ~~~         \"orgEventTypes\": [           \"plannedVesselArrival\"           ],          \"docEventFilters\": [           {\"action\": \"submitted\",            \"docType\": \"SHIPPING_INSTRUCTIONS\"}          ]  ~~~ 


// markup not found, no include::{specDir}api/v1/subscriptions/org/POST/spec.adoc[opts=optional]



===== Parameters


===== Body Parameter

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| OrgSubscription 
| orgSubscription <<OrgSubscription>> 
| X 
|  
|  

|===         





===== Return Type

<<MessageResponseV1>>


===== Content Type

* application/json

===== Responses

.http response codes
[cols="2,3,1"]
|===         
| Code | Message | Datatype 


| 202
| Accepted
|  <<MessageResponseV1>>


| 429
| Too Many Requests
|  <<RateLimitResponseModel>>

|===         

===== Samples


// markup not found, no include::{snippetDir}api/v1/subscriptions/org/POST/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}api/v1/subscriptions/org/POST/http-response.adoc[opts=optional]



// file not found, no * wiremock data link :api/v1/subscriptions/org/POST/POST.json[]


ifdef::internal-generation[]
===== Implementation

// markup not found, no include::{specDir}api/v1/subscriptions/org/POST/implementation.adoc[opts=optional]


endif::internal-generation[]


[.createPortUsingPOST]
==== createPortUsingPOST
    
`POST /api/v1/subscriptions/port`

Create a subscription using a port code

===== Description 

Configures a webhook for a port. The webhook will receive all events for all consignments and transport equipment that pass through that port.   The `uri` field is required.  An optional `sharedSecret` can be included that will be used to calculate the Hash-based Message Authentication Code(or HMAC) signature.  Our service currently supports the `HmacSHA256` algorithm (see http://www.ietf.org/rfc/rfc2104.txt).   Please note that we have shifted from SHA1 in the deprecated endpoints to SHA256 in these endpoints  The HMAC signature is the product of a hash function applied to the body of a message along with the `sharedSecret`. When Shipping Information Pipeline sends a subscriber an event, it stores the signature on the header named `X-GTD-Signature`.  When the subscriber's server receives the event, it uses the same `sharedSecret` to compute the same HMAC.  If the computed HMAC equals the value found in the header named `X-GTD-Signature` the request is authenticated. For the signatures to match, not only must the `sharedSecret` used at both ends of the transaction match, but the message body must also match exactly.  Below is a Java sample to validate the `X-GTD-Signature`. ~~~ String xGTDSignature = \"hashvaluefromheader\"; Mac hmac = Mac.getInstance(\"HmacSHA256\"); hmac.init(new SecretKeySpec(\"sharedSecretValue\".getBytes( Charset.forName(\"UTF-8\")), \"HmacSHA256\")); String calculatedSignature = Hex.encodeHexString(hmac.doFinal(event.getBytes(Charset.forName(\"UTF-8\")))); logger.debug(className+\"calculatedSignature: \"+calculatedSignature); if(xGTDSignature.equals(calculatedSignature)){     // signed body matched } ~~~ For more information see: * https://docs.oracle.com/javase/8/docs/api/javax/crypto/Mac.html * https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#Mac * http://www.ietf.org/rfc/rfc2104.txt  The webhook will receive arrays of events as the body of an HTTP POST request. The webhook must respond with an HTTP success code response. Webhooks that do not respond promptly (within 5 seconds) more than once over a period of time (one hour) will be disabled for a short duration (10 seconds after the second non-response, 1 hour on all subsequent non-responses), meaning the platform will not attempt to publish events to the webhook while it is disabled. A webhook will be instantly enabled if it responds one time within 5 seconds and the platform will send all the unpublished events at that time. If the webhook has not responded for 5 days, all unpublished events are discarded and any new events will not be saved. The webhook will still be instantly enabled if it responds within the required time.    Each event published to the webhook will contain all information originally published in the event, plus additional fields added during the processing of events for the convenience of associating events with the consignments and transport equipment to which they belong.  * If the event is on the level of a transport equipment, both the \"transportEquipmentId\" and \"equipmentNumber\" will be added to the event if they were not originally present. If the transport equipment was associated with any consignments at the time the event was sent to the webhook, then the \"associatedConsignmentIds\" field will be populated with the consignmentId of all those consignments.  * If the event was published to a consignment, the \"consignmentId\" associated with the consignment will be added to the event.  * All events are given an internal \"type\" field corresponding to the code of their type (e.g. \"E025\").  Here is an example.  ~~~ [     {         \"eventSubmissionTime\": 1523633968187,         \"type\": \"E021\",         \"originatorId\": \"origninatorId\",         \"eventOccurrenceTime\": 1523633968187,         \"originatorName\": \"originatorName\",         \"transportEquipmentId\": \"6c995b93-ddf8-4062-a519-99db31a111ef\",         \"equipmentNumber\": \"Test-V1-T003-1523633966168-C1\",         \"transportationPhase\": \"Transshipment\",         \"associatedConsignmentIds\": [\"ConsignmentId1\", \"ConsignmentId2\"],         \"location\": {             \"type\": \"UN/Locode\",             \"value\": \"NLRTM\"         }     }] ~~~ Filtering on Event Types:  * The event type and document type filters filter ON events. Only the events that match the filter definitions will be sent on the subscription. The list of valid event types can be found in the Query API: GET /api/v1/eventTypes. * ...EventTypes is an array of event types. These can be the full names of the events (e.g. \"plannedVesselArrival\") or the Exxx code (e.g. \"E310\")\". * docEventFilters is an array of action and document type pairs. If action is not specified, then document events whose document type matches the filter, regardless of their associated action, will be sent on the subscription. * To allow all document events to be sent on the subscription, just add \"documentEvents\" to the ...EventTypes array and do not specify docEventFilters.   The following examples are for an org subscription. Replace org with port or country in orgEventTypes if using port or country subscriptions: * To subscribe to PRO_FORMA_INVOICE submitted document events:   ~~~         \"docEventFilters\": [           {\"action\": \"submitted\",            \"docType\": \"PRO_FORMA_INVOICE\"}          ]  ~~~  * To subscribe to all document events:   ~~~         \"orgEventTypes\": [           \"documentEvents\"           ]  ~~~ * To subscribe to plannedVesselArrival and SHIPPING_INSTRUCTIONS submitted events:   ~~~         \"orgEventTypes\": [           \"plannedVesselArrival\"           ],          \"docEventFilters\": [           {\"action\": \"submitted\",            \"docType\": \"SHIPPING_INSTRUCTIONS\"}          ]  ~~~ 


// markup not found, no include::{specDir}api/v1/subscriptions/port/POST/spec.adoc[opts=optional]



===== Parameters


===== Body Parameter

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| PortSubscription 
| portSubscription <<PortSubscription>> 
| X 
|  
|  

|===         





===== Return Type

<<MessageResponseV1>>


===== Content Type

* application/json

===== Responses

.http response codes
[cols="2,3,1"]
|===         
| Code | Message | Datatype 


| 202
| Accepted
|  <<MessageResponseV1>>


| 429
| Too Many Requests
|  <<RateLimitResponseModel>>

|===         

===== Samples


// markup not found, no include::{snippetDir}api/v1/subscriptions/port/POST/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}api/v1/subscriptions/port/POST/http-response.adoc[opts=optional]



// file not found, no * wiremock data link :api/v1/subscriptions/port/POST/POST.json[]


ifdef::internal-generation[]
===== Implementation

// markup not found, no include::{specDir}api/v1/subscriptions/port/POST/implementation.adoc[opts=optional]


endif::internal-generation[]


[.createProvinceUsingPOST]
==== createProvinceUsingPOST
    
`POST /api/v1/subscriptions/province`

Create a subscription to your province

===== Description 

Configures a webhook for a province. The webhook will receive all events for all consignments and transport equipment that pass through any port in a set of ports. This set is provided in the optional 'ports' field in the subscription. If the user does not specify a set of ports, then the subscription will default to all the ports for which this org has a province role.   The `uri` field is required.  An optional `sharedSecret` can be included that will be used to calculate the Hash-based Message Authentication Code(or HMAC) signature.  Our service currently supports the `HmacSHA256` algorithm (see http://www.ietf.org/rfc/rfc2104.txt).   Please note that we have shifted from SHA1 in the deprecated endpoints to SHA256 in these endpoints  The HMAC signature is the product of a hash function applied to the body of a message along with the `sharedSecret`. When Shipping Information Pipeline sends a subscriber an event, it stores the signature on the header named `X-GTD-Signature`.  When the subscriber's server receives the event, it uses the same `sharedSecret` to compute the same HMAC.  If the computed HMAC equals the value found in the header named `X-GTD-Signature` the request is authenticated. For the signatures to match, not only must the `sharedSecret` used at both ends of the transaction match, but the message body must also match exactly.  Below is a Java sample to validate the `X-GTD-Signature`. ~~~ String xGTDSignature = \"hashvaluefromheader\"; Mac hmac = Mac.getInstance(\"HmacSHA256\"); hmac.init(new SecretKeySpec(\"sharedSecretValue\".getBytes( Charset.forName(\"UTF-8\")), \"HmacSHA256\")); String calculatedSignature = Hex.encodeHexString(hmac.doFinal(event.getBytes(Charset.forName(\"UTF-8\")))); logger.debug(className+\"calculatedSignature: \"+calculatedSignature); if(xGTDSignature.equals(calculatedSignature)){     // signed body matched } ~~~ For more information see: * https://docs.oracle.com/javase/8/docs/api/javax/crypto/Mac.html * https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#Mac * http://www.ietf.org/rfc/rfc2104.txt  The webhook will receive arrays of events as the body of an HTTP POST request. The webhook must respond with an HTTP success code response. Webhooks that do not respond promptly (within 5 seconds) more than once over a period of time (one hour) will be disabled for a short duration (10 seconds after the second non-response, 1 hour on all subsequent non-responses), meaning the platform will not attempt to publish events to the webhook while it is disabled. A webhook will be instantly enabled if it responds one time within 5 seconds and the platform will send all the unpublished events at that time. If the webhook has not responded for 5 days, all unpublished events are discarded and any new events will not be saved. The webhook will still be instantly enabled if it responds within the required time.    Each event published to the webhook will contain all information originally published in the event, plus additional fields added during the processing of events for the convenience of associating events with the consignments and transport equipment to which they belong.  * If the event is on the level of a transport equipment, both the \"transportEquipmentId\" and \"equipmentNumber\" will be added to the event if they were not originally present. If the transport equipment was associated with any consignments at the time the event was sent to the webhook, then the \"associatedConsignmentIds\" field will be populated with the consignmentId of all those consignments.  * If the event was published to a consignment, the \"consignmentId\" associated with the consignment will be added to the event.  * All events are given an internal \"type\" field corresponding to the code of their type (e.g. \"E025\").  Here is an example.  ~~~ [     {         \"eventSubmissionTime\": 1523633968187,         \"type\": \"E021\",         \"originatorId\": \"origninatorId\",         \"eventOccurrenceTime\": 1523633968187,         \"originatorName\": \"originatorName\",         \"transportEquipmentId\": \"6c995b93-ddf8-4062-a519-99db31a111ef\",         \"equipmentNumber\": \"Test-V1-T003-1523633966168-C1\",         \"transportationPhase\": \"Transshipment\",         \"associatedConsignmentIds\": [\"ConsignmentId1\", \"ConsignmentId2\"],         \"location\": {             \"type\": \"UN/Locode\",             \"value\": \"NLRTM\"         }     }] ~~~ Filtering on Event Types:  * The event type and document type filters filter ON events. Only the events that match the filter definitions will be sent on the subscription. The list of valid event types can be found in the Query API: GET /api/v1/eventTypes. * ...EventTypes is an array of event types. These can be the full names of the events (e.g. \"plannedVesselArrival\") or the Exxx code (e.g. \"E310\")\". * docEventFilters is an array of action and document type pairs. If action is not specified, then document events whose document type matches the filter, regardless of their associated action, will be sent on the subscription. * To allow all document events to be sent on the subscription, just add \"documentEvents\" to the ...EventTypes array and do not specify docEventFilters.   The following examples are for an org subscription. Replace org with port or country in orgEventTypes if using port or country subscriptions: * To subscribe to PRO_FORMA_INVOICE submitted document events:   ~~~         \"docEventFilters\": [           {\"action\": \"submitted\",            \"docType\": \"PRO_FORMA_INVOICE\"}          ]  ~~~  * To subscribe to all document events:   ~~~         \"orgEventTypes\": [           \"documentEvents\"           ]  ~~~ * To subscribe to plannedVesselArrival and SHIPPING_INSTRUCTIONS submitted events:   ~~~         \"orgEventTypes\": [           \"plannedVesselArrival\"           ],          \"docEventFilters\": [           {\"action\": \"submitted\",            \"docType\": \"SHIPPING_INSTRUCTIONS\"}          ]  ~~~ 


// markup not found, no include::{specDir}api/v1/subscriptions/province/POST/spec.adoc[opts=optional]



===== Parameters


===== Body Parameter

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| ProvinceSubscription 
| provinceSubscription <<ProvinceSubscription>> 
| X 
|  
|  

|===         





===== Return Type

<<MessageResponseV1>>


===== Content Type

* application/json

===== Responses

.http response codes
[cols="2,3,1"]
|===         
| Code | Message | Datatype 


| 202
| Accepted
|  <<MessageResponseV1>>


| 429
| Too Many Requests
|  <<RateLimitResponseModel>>

|===         

===== Samples


// markup not found, no include::{snippetDir}api/v1/subscriptions/province/POST/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}api/v1/subscriptions/province/POST/http-response.adoc[opts=optional]



// file not found, no * wiremock data link :api/v1/subscriptions/province/POST/POST.json[]


ifdef::internal-generation[]
===== Implementation

// markup not found, no include::{specDir}api/v1/subscriptions/province/POST/implementation.adoc[opts=optional]


endif::internal-generation[]


[.createTerminalUsingPOST]
==== createTerminalUsingPOST
    
`POST /api/v1/subscriptions/terminal`

Create a subscription using a terminal code

===== Description 

Configures a webhook for a terminal. The webhook will receive all events for all consignments and transport equipment that pass through that terminal.   The `uri` field is required.  An optional `sharedSecret` can be included that will be used to calculate the Hash-based Message Authentication Code(or HMAC) signature.  Our service currently supports the `HmacSHA256` algorithm (see http://www.ietf.org/rfc/rfc2104.txt).   Please note that we have shifted from SHA1 in the deprecated endpoints to SHA256 in these endpoints  The HMAC signature is the product of a hash function applied to the body of a message along with the `sharedSecret`. When Shipping Information Pipeline sends a subscriber an event, it stores the signature on the header named `X-GTD-Signature`.  When the subscriber's server receives the event, it uses the same `sharedSecret` to compute the same HMAC.  If the computed HMAC equals the value found in the header named `X-GTD-Signature` the request is authenticated. For the signatures to match, not only must the `sharedSecret` used at both ends of the transaction match, but the message body must also match exactly.  Below is a Java sample to validate the `X-GTD-Signature`. ~~~ String xGTDSignature = \"hashvaluefromheader\"; Mac hmac = Mac.getInstance(\"HmacSHA256\"); hmac.init(new SecretKeySpec(\"sharedSecretValue\".getBytes( Charset.forName(\"UTF-8\")), \"HmacSHA256\")); String calculatedSignature = Hex.encodeHexString(hmac.doFinal(event.getBytes(Charset.forName(\"UTF-8\")))); logger.debug(className+\"calculatedSignature: \"+calculatedSignature); if(xGTDSignature.equals(calculatedSignature)){     // signed body matched } ~~~ For more information see: * https://docs.oracle.com/javase/8/docs/api/javax/crypto/Mac.html * https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#Mac * http://www.ietf.org/rfc/rfc2104.txt  The webhook will receive arrays of events as the body of an HTTP POST request. The webhook must respond with an HTTP success code response. Webhooks that do not respond promptly (within 5 seconds) more than once over a period of time (one hour) will be disabled for a short duration (10 seconds after the second non-response, 1 hour on all subsequent non-responses), meaning the platform will not attempt to publish events to the webhook while it is disabled. A webhook will be instantly enabled if it responds one time within 5 seconds and the platform will send all the unpublished events at that time. If the webhook has not responded for 5 days, all unpublished events are discarded and any new events will not be saved. The webhook will still be instantly enabled if it responds within the required time.    Each event published to the webhook will contain all information originally published in the event, plus additional fields added during the processing of events for the convenience of associating events with the consignments and transport equipment to which they belong.  * If the event is on the level of a transport equipment, both the \"transportEquipmentId\" and \"equipmentNumber\" will be added to the event if they were not originally present. If the transport equipment was associated with any consignments at the time the event was sent to the webhook, then the \"associatedConsignmentIds\" field will be populated with the consignmentId of all those consignments.  * If the event was published to a consignment, the \"consignmentId\" associated with the consignment will be added to the event.  * All events are given an internal \"type\" field corresponding to the code of their type (e.g. \"E025\").  Here is an example.  ~~~ [     {         \"eventSubmissionTime\": 1523633968187,         \"type\": \"E021\",         \"originatorId\": \"origninatorId\",         \"eventOccurrenceTime\": 1523633968187,         \"originatorName\": \"originatorName\",         \"transportEquipmentId\": \"6c995b93-ddf8-4062-a519-99db31a111ef\",         \"equipmentNumber\": \"Test-V1-T003-1523633966168-C1\",         \"transportationPhase\": \"Transshipment\",         \"associatedConsignmentIds\": [\"ConsignmentId1\", \"ConsignmentId2\"],         \"location\": {             \"type\": \"UN/Locode\",             \"value\": \"NLRTM\"         }     }] ~~~ 


// markup not found, no include::{specDir}api/v1/subscriptions/terminal/POST/spec.adoc[opts=optional]



===== Parameters


===== Body Parameter

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| TerminalSubscription 
| terminalSubscription <<TerminalSubscription>> 
| X 
|  
|  

|===         





===== Return Type

<<MessageResponseV1>>


===== Content Type

* application/json

===== Responses

.http response codes
[cols="2,3,1"]
|===         
| Code | Message | Datatype 


| 202
| Accepted
|  <<MessageResponseV1>>


| 429
| Too Many Requests
|  <<RateLimitResponseModel>>

|===         

===== Samples


// markup not found, no include::{snippetDir}api/v1/subscriptions/terminal/POST/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}api/v1/subscriptions/terminal/POST/http-response.adoc[opts=optional]



// file not found, no * wiremock data link :api/v1/subscriptions/terminal/POST/POST.json[]


ifdef::internal-generation[]
===== Implementation

// markup not found, no include::{specDir}api/v1/subscriptions/terminal/POST/implementation.adoc[opts=optional]


endif::internal-generation[]


[.deleteAllUsingDELETE]
==== deleteAllUsingDELETE
    
`DELETE /api/v1/subscriptions`

Delete all subscriptions

===== Description 

Deletes all subscriptions. You can only delete subscriptions created by the organization with which you are currently authenticated.


// markup not found, no include::{specDir}api/v1/subscriptions/DELETE/spec.adoc[opts=optional]



===== Parameters







===== Return Type

<<DeleteResponse>>


===== Content Type

* application/json

===== Responses

.http response codes
[cols="2,3,1"]
|===         
| Code | Message | Datatype 


| 200
| OK
|  <<DeleteResponse>>


| 429
| Too Many Requests
|  <<RateLimitResponseModel>>

|===         

===== Samples


// markup not found, no include::{snippetDir}api/v1/subscriptions/DELETE/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}api/v1/subscriptions/DELETE/http-response.adoc[opts=optional]



// file not found, no * wiremock data link :api/v1/subscriptions/DELETE/DELETE.json[]


ifdef::internal-generation[]
===== Implementation

// markup not found, no include::{specDir}api/v1/subscriptions/DELETE/implementation.adoc[opts=optional]


endif::internal-generation[]


[.deleteUsingDELETE]
==== deleteUsingDELETE
    
`DELETE /api/v1/subscriptions/{id}`

Delete a subscription

===== Description 

Deletes a subscription. You can only delete subscriptions created by the organization with which you are currently authenticated.


// markup not found, no include::{specDir}api/v1/subscriptions/\{id\}/DELETE/spec.adoc[opts=optional]



===== Parameters

====== Path Parameters

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| id 
| id  
| X 
| null 
|  

|===         






===== Return Type

<<MessageResponseV1>>


===== Content Type

* application/json

===== Responses

.http response codes
[cols="2,3,1"]
|===         
| Code | Message | Datatype 


| 200
| OK
|  <<MessageResponseV1>>


| 429
| Too Many Requests
|  <<RateLimitResponseModel>>

|===         

===== Samples


// markup not found, no include::{snippetDir}api/v1/subscriptions/\{id\}/DELETE/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}api/v1/subscriptions/\{id\}/DELETE/http-response.adoc[opts=optional]



// file not found, no * wiremock data link :api/v1/subscriptions/{id}/DELETE/DELETE.json[]


ifdef::internal-generation[]
===== Implementation

// markup not found, no include::{specDir}api/v1/subscriptions/\{id\}/DELETE/implementation.adoc[opts=optional]


endif::internal-generation[]


[.getAllUsingGET]
==== getAllUsingGET
    
`GET /api/v1/subscriptions`

Get all subscriptions

===== Description 

Get all subscriptions. This will return only subscriptions created by the organization with which you are currently authenticated.


// markup not found, no include::{specDir}api/v1/subscriptions/GET/spec.adoc[opts=optional]



===== Parameters





====== Query Parameters

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| size 
| Optional, number of subscriptions to return, max 1000  
| - 
| 1000 
|  

| from 
| Optional, bookmark to get the next chunk of results to a previously executed query  
| - 
| null 
|  

| type 
| Optional, type of subscriptions to return  
| - 
| all 
|  

| name 
| Optional, name value to search, full or partial value. Case sensitive. Wildcard chars automatically added to beginning and end  
| - 
| null 
|  

| sort_by 
| Optional, the field on which to order the results  
| - 
| name 
|  

| sort_order 
| Optional, the sort order to apply to sort_by field  
| - 
| ascending 
|  

|===         


===== Return Type

<<SubscriptionQueryResponse>>


===== Content Type

* application/json

===== Responses

.http response codes
[cols="2,3,1"]
|===         
| Code | Message | Datatype 


| 200
| OK
|  <<SubscriptionQueryResponse>>


| 429
| Too Many Requests
|  <<RateLimitResponseModel>>

|===         

===== Samples


// markup not found, no include::{snippetDir}api/v1/subscriptions/GET/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}api/v1/subscriptions/GET/http-response.adoc[opts=optional]



// file not found, no * wiremock data link :api/v1/subscriptions/GET/GET.json[]


ifdef::internal-generation[]
===== Implementation

// markup not found, no include::{specDir}api/v1/subscriptions/GET/implementation.adoc[opts=optional]


endif::internal-generation[]


[.getSubscriptionUsingGET]
==== getSubscriptionUsingGET
    
`GET /api/v1/subscriptions/{id}`

Retrieve a subscription

===== Description 

Retrieve the Subscription which has the given ID. You will only be able to retrieve this subscription if it was created by the organization with which you are currently authenticated.


// markup not found, no include::{specDir}api/v1/subscriptions/\{id\}/GET/spec.adoc[opts=optional]



===== Parameters

====== Path Parameters

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| id 
| id  
| X 
| null 
|  

|===         






===== Return Type

<<SubscriptionResponseV1>>


===== Content Type

* application/json

===== Responses

.http response codes
[cols="2,3,1"]
|===         
| Code | Message | Datatype 


| 200
| OK
|  <<SubscriptionResponseV1>>


| 429
| Too Many Requests
|  <<RateLimitResponseModel>>

|===         

===== Samples


// markup not found, no include::{snippetDir}api/v1/subscriptions/\{id\}/GET/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}api/v1/subscriptions/\{id\}/GET/http-response.adoc[opts=optional]



// file not found, no * wiremock data link :api/v1/subscriptions/{id}/GET/GET.json[]


ifdef::internal-generation[]
===== Implementation

// markup not found, no include::{specDir}api/v1/subscriptions/\{id\}/GET/implementation.adoc[opts=optional]


endif::internal-generation[]


[.updateSubscriptionUsingPUT]
==== updateSubscriptionUsingPUT
    
`PUT /api/v1/subscriptions/{id}`

Update the webhook for a subscription.

===== Description 

Update the webhook for the subscription with the given Id. You can only update subscriptions created by the organization with which you are currently authenticated.


// markup not found, no include::{specDir}api/v1/subscriptions/\{id\}/PUT/spec.adoc[opts=optional]



===== Parameters

====== Path Parameters

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| id 
| id  
| X 
| null 
|  

|===         

===== Body Parameter

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| Webhook 
| webhook <<Webhook>> 
| X 
|  
|  

|===         





===== Return Type

<<MessageResponseV1>>


===== Content Type

* application/json

===== Responses

.http response codes
[cols="2,3,1"]
|===         
| Code | Message | Datatype 


| 202
| Accepted
|  <<MessageResponseV1>>


| 429
| Too Many Requests
|  <<RateLimitResponseModel>>

|===         

===== Samples


// markup not found, no include::{snippetDir}api/v1/subscriptions/\{id\}/PUT/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}api/v1/subscriptions/\{id\}/PUT/http-response.adoc[opts=optional]



// file not found, no * wiremock data link :api/v1/subscriptions/{id}/PUT/PUT.json[]


ifdef::internal-generation[]
===== Implementation

// markup not found, no include::{specDir}api/v1/subscriptions/\{id\}/PUT/implementation.adoc[opts=optional]


endif::internal-generation[]


[.updateSubscriptionV2UsingPATCH]
==== updateSubscriptionV2UsingPATCH
    
`PATCH /api/v1/subscriptions/{id}`

Update the webhook and name of a subscription.

===== Description 

Update the webhook and the name for the subscription with the given Id. Both are optional but one of the two must be specified.  You can only update subscriptions created by the organization with which you are currently authenticated.


// markup not found, no include::{specDir}api/v1/subscriptions/\{id\}/PATCH/spec.adoc[opts=optional]



===== Parameters

====== Path Parameters

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| id 
| id  
| X 
| null 
|  

|===         

===== Body Parameter

[cols="2,3,1,1,1"]
|===         
|Name| Description| Required| Default| Pattern

| ModifySubscription 
| modifySubscription <<ModifySubscription>> 
| X 
|  
|  

|===         





===== Return Type

<<MessageResponseV1>>


===== Content Type

* application/json

===== Responses

.http response codes
[cols="2,3,1"]
|===         
| Code | Message | Datatype 


| 202
| Accepted
|  <<MessageResponseV1>>


| 429
| Too Many Requests
|  <<RateLimitResponseModel>>

|===         

===== Samples


// markup not found, no include::{snippetDir}api/v1/subscriptions/\{id\}/PATCH/http-request.adoc[opts=optional]


// markup not found, no include::{snippetDir}api/v1/subscriptions/\{id\}/PATCH/http-response.adoc[opts=optional]



// file not found, no * wiremock data link :api/v1/subscriptions/{id}/PATCH/PATCH.json[]


ifdef::internal-generation[]
===== Implementation

// markup not found, no include::{specDir}api/v1/subscriptions/\{id\}/PATCH/implementation.adoc[opts=optional]


endif::internal-generation[]


[#models]
== Models


[#CountrySubscription]
=== _CountrySubscription_ 



[.fields-CountrySubscription]
[cols="2,1,2,4,1"]
|===         
| Field Name| Required| Type| Description| Format

| name 
|  
| String  
| The name to be associated with this subscription
|  

| country 
| X 
| String  
| The 2-character country code for the subscription
|  _Enum:_ AD, AE, AF, AG, AI, AL, AM, AO, AQ, AR, AS, AT, AU, AW, AX, AZ, BA, BB, BD, BE, BF, BG, BH, BI, BJ, BL, BM, BN, BO, BQ, BR, BS, BT, BV, BW, BY, BZ, CA, CC, CD, CF, CG, CH, CI, CK, CL, CM, CN, CO, CR, CU, CV, CW, CX, CY, CZ, DE, DJ, DK, DM, DO, DZ, EC, EE, EG, EH, ER, ES, ET, FI, FJ, FK, FM, FO, FR, GA, GB, GD, GE, GF, GG, GH, GI, GL, GM, GN, GP, GQ, GR, GS, GT, GU, GW, GY, HK, HM, HN, HR, HT, HU, ID, IE, IL, IM, IN, IO, IQ, IR, IS, IT, JE, JM, JO, JP, KE, KG, KH, KI, KM, KN, KP, KR, KW, KY, KZ, LA, LB, LC, LI, LK, LR, LS, LT, LU, LV, LY, MA, MC, MD, ME, MF, MG, MH, MK, ML, MM, MN, MO, MP, MQ, MR, MS, MT, MU, MV, MW, MX, MY, MZ, NA, NC, NE, NF, NG, NI, NL, false, NP, NR, NU, NZ, OM, PA, PE, PF, PG, PH, PK, PL, PM, PN, PR, PS, PT, PW, PY, QA, RE, RO, RS, RU, RW, SA, SB, SC, SD, SE, SG, SH, SI, SJ, SK, SL, SM, SN, SO, SR, SS, ST, SV, SX, SY, SZ, TC, TD, TF, TG, TH, TJ, TK, TL, TM, TN, TO, TR, TT, TV, TW, TZ, UA, UG, UM, US, UY, UZ, VA, VC, VE, VG, VI, VN, VU, WF, WS, YE, YT, ZA, ZM, ZW, OA, OB, OC, OD, OE, OF, OG, OZ, XA, XB, XC, XD, XE, XF, XG, XH, XI, XJ, XK, XL, XM, XN, XO, XP, XQ, XR, XS, XT, XU, XV, XW, XX, XY, XZ, 

| countryRole 
|  
| String  
| The role of the country for this subscription. The subscription will only be sent events where the given country is involved. 
|  _Enum:_ ImportCountry, ExportCountry, FirstPortOfEntryCountry, CargoRemainingOnboardCountries, TransitImportCountries, TransitExportCountries, 

| countryEventTypes 
|  
| List  of <<string>> 
| An array of event types. The subscription will only receive events whose type is in this list. This is required if the user supplies a \&quot;countryRole\&quot;. These can be the full names of the events (e.g. \&quot;plannedVesselArrival\&quot;) or the Exxx code (e.g. \&quot;E310\&quot;)
|  

| docEventFilters 
|  
| List  of <<DocEventFilter>> 
| An array of document filters.  For each filter specify a document type and the action associated with that document type. The subscription will only receive document events whose type and action are in this list. The action may either be a specific action (e.g. \&quot;submitted\&quot;) in which case the subscription will receive document events of the specified type provided they also have same action.  The action value may also be omitted or null which means as long as the document type matches all actions will match.
|  

| webhook 
| X 
| Webhook  
| 
|  

|===


[#DeleteResponse]
=== _DeleteResponse_ 



[.fields-DeleteResponse]
[cols="2,1,2,4,1"]
|===         
| Field Name| Required| Type| Description| Format

| message 
| X 
| String  
| Message describing the status
|  

| count 
| X 
| Long  
| Number of subscriptions deleted
| int64 

|===


[#DocEventFilter]
=== _DocEventFilter_ 



[.fields-DocEventFilter]
[cols="2,1,2,4,1"]
|===         
| Field Name| Required| Type| Description| Format

| action 
|  
| String  
| The document action for the subscription
|  _Enum:_ submitted, approved, rejected, canceled, issued, transferred, surrendered, switchedtopaper, 

| docType 
| X 
| String  
| The document type for the subscription
|  

|===


[#MessageResponseV1]
=== _MessageResponseV1_ 



[.fields-MessageResponseV1]
[cols="2,1,2,4,1"]
|===         
| Field Name| Required| Type| Description| Format

| message 
| X 
| String  
| Message describing the status
|  

| subscriptionId 
| X 
| String  
| Subscription ID
|  

|===


[#ModifySubscription]
=== _ModifySubscription_ 



[.fields-ModifySubscription]
[cols="2,1,2,4,1"]
|===         
| Field Name| Required| Type| Description| Format

| webhook 
|  
| Webhook  
| 
|  

| name 
|  
| String  
| The name to be associated with this subscription
|  

|===


[#OrgSubscription]
=== _OrgSubscription_ 



[.fields-OrgSubscription]
[cols="2,1,2,4,1"]
|===         
| Field Name| Required| Type| Description| Format

| name 
|  
| String  
| The name to be associated with this subscription
|  

| orgEventTypes 
|  
| List  of <<string>> 
| An array of event types. The subscription will only receive events whose type is in this list. These can be the full names of the events (e.g. \\\&quot;plannedVesselArrival\\\&quot;) or the Exxx code (e.g. \\\&quot;E310\\\&quot;)\&quot;
|  

| docEventFilters 
|  
| List  of <<DocEventFilter>> 
| An array of document filters.  For each filter specify a document type and the action associated with that document type. The subscription will only receive document events whose type and action are in this list. The action may either be a specific action (e.g. \&quot;submitted\&quot;) in which case the subscription will receive document events of the specified type provided they also have same action.  The action value may also be omitted or null which means as long as the document type matches all actions will match.
|  

| webhook 
| X 
| Webhook  
| 
|  

|===


[#PortSubscription]
=== _PortSubscription_ 



[.fields-PortSubscription]
[cols="2,1,2,4,1"]
|===         
| Field Name| Required| Type| Description| Format

| name 
|  
| String  
| The name to be associated with this subscription
|  

| port 
| X 
| String  
| The identifier of the port. This should be a 5-character UN/Locode
|  

| portRole 
|  
| String  
| The role of the port for this subscription. The subscription will only be sent events where the given port is involved. 
|  _Enum:_ TransshipmentPorts, EntryPort, ExitPort, 

| portEventTypes 
|  
| List  of <<string>> 
| An array of event types. The subscription will only receive events whose type is in this list. Required if supplying a value for \&quot;portRole\&quot;. These can be the full names of the events (e.g. \\\&quot;plannedVesselArrival\\\&quot;) or the Exxx code (e.g. \\\&quot;E310\\\&quot;)\&quot;
|  

| docEventFilters 
|  
| List  of <<DocEventFilter>> 
| An array of document filters.  For each filter specify a document type and the action associated with that document type. The subscription will only receive document events whose type and action are in this list. The action may either be a specific action (e.g. \&quot;submitted\&quot;) in which case the subscription will receive document events of the specified type provided they also have same action.  The action value may also be omitted or null which means as long as the document type matches all actions will match.
|  

| webhook 
| X 
| Webhook  
| 
|  

|===


[#ProvinceSubscription]
=== _ProvinceSubscription_ 



[.fields-ProvinceSubscription]
[cols="2,1,2,4,1"]
|===         
| Field Name| Required| Type| Description| Format

| name 
|  
| String  
| The name to be associated with this subscription
|  

| ports 
|  
| List  of <<string>> 
| The 5-character UN/Locode identifiers for ports. The subscription will receive events for all trade objects passing through these ports. The org creating this subscription must have an import / export authority role for each port. If this field is not included in the request, then the user will be subscribed to every port for which their org has an import / export authority role 
|  

| provinceEventTypes 
|  
| List  of <<string>> 
| An array of event types. The subscription will only receive events whose type is in this list. These can be the full names of the events (e.g. \&quot;plannedVesselArrival\&quot;) or the Exxx code (e.g. \&quot;E310\&quot;)
|  

| docEventFilters 
|  
| List  of <<DocEventFilter>> 
| An array of document filters.  For each filter specify a document type and the action associated with that document type. The subscription will only receive document events whose type and action are in this list. The action may either be a specific action (e.g. \&quot;submitted\&quot;) in which case the subscription will receive document events of the specified type provided they also have same action.  The action value may also be omitted or null which means as long as the document type matches all actions will match.
|  

| webhook 
| X 
| Webhook  
| 
|  

|===


[#RateLimitResponseModel]
=== _RateLimitResponseModel_ 



[.fields-RateLimitResponseModel]
[cols="2,1,2,4,1"]
|===         
| Field Name| Required| Type| Description| Format

| error 
| X 
| String  
| Human readable http response
|  

| message 
| X 
| String  
| Translated error message
|  

| path 
| X 
| String  
| Path to API called
|  

| status 
| X 
| Integer  
| HTTP status (429)
| int32 

| timestamp 
| X 
| Long  
| Timestamp at which the rejected request was submitted, in epoch time
| int64 

|===


[#SubscriptionQueryResponse]
=== _SubscriptionQueryResponse_ 



[.fields-SubscriptionQueryResponse]
[cols="2,1,2,4,1"]
|===         
| Field Name| Required| Type| Description| Format

| total 
| X 
| Long  
| The total number of subscriptions represented in this object
| int64 

| size 
|  
| Integer  
| Number of subscriptions in this result
| int32 

| newFrom 
|  
| String  
| Number of initial subscriptions that were skipped
|  

| subscriptions 
| X 
| List  of <<SubscriptionResponseV1>> 
| The list of subscriptions
|  

|===


[#SubscriptionResponseV1]
=== _SubscriptionResponseV1_ 



[.fields-SubscriptionResponseV1]
[cols="2,1,2,4,1"]
|===         
| Field Name| Required| Type| Description| Format

| id 
| X 
| String  
| Unique ID for this subscription
|  

| webhook 
| X 
| Webhook  
| 
|  

| name 
|  
| String  
| Name given to the subscription
|  

| country 
|  
| String  
| If this is a country subscription, the 2-character country code for the subscription
|  _Enum:_ AD, AE, AF, AG, AI, AL, AM, AO, AQ, AR, AS, AT, AU, AW, AX, AZ, BA, BB, BD, BE, BF, BG, BH, BI, BJ, BL, BM, BN, BO, BQ, BR, BS, BT, BV, BW, BY, BZ, CA, CC, CD, CF, CG, CH, CI, CK, CL, CM, CN, CO, CR, CU, CV, CW, CX, CY, CZ, DE, DJ, DK, DM, DO, DZ, EC, EE, EG, EH, ER, ES, ET, FI, FJ, FK, FM, FO, FR, GA, GB, GD, GE, GF, GG, GH, GI, GL, GM, GN, GP, GQ, GR, GS, GT, GU, GW, GY, HK, HM, HN, HR, HT, HU, ID, IE, IL, IM, IN, IO, IQ, IR, IS, IT, JE, JM, JO, JP, KE, KG, KH, KI, KM, KN, KP, KR, KW, KY, KZ, LA, LB, LC, LI, LK, LR, LS, LT, LU, LV, LY, MA, MC, MD, ME, MF, MG, MH, MK, ML, MM, MN, MO, MP, MQ, MR, MS, MT, MU, MV, MW, MX, MY, MZ, NA, NC, NE, NF, NG, NI, NL, false, NP, NR, NU, NZ, OM, PA, PE, PF, PG, PH, PK, PL, PM, PN, PR, PS, PT, PW, PY, QA, RE, RO, RS, RU, RW, SA, SB, SC, SD, SE, SG, SH, SI, SJ, SK, SL, SM, SN, SO, SR, SS, ST, SV, SX, SY, SZ, TC, TD, TF, TG, TH, TJ, TK, TL, TM, TN, TO, TR, TT, TV, TW, TZ, UA, UG, UM, US, UY, UZ, VA, VC, VE, VG, VI, VN, VU, WF, WS, YE, YT, ZA, ZM, ZW, OA, OB, OC, OD, OE, OF, OG, OZ, XA, XB, XC, XD, XE, XF, XG, XH, XI, XJ, XK, XL, XM, XN, XO, XP, XQ, XR, XS, XT, XU, XV, XW, XX, XY, XZ, 

| countryRole 
|  
| String  
| If this is a country subscription, the role the country must play in the transport plan of a consignment or container transport to receive events
|  _Enum:_ ImportCountry, ExportCountry, FirstPortOfEntryCountry, CargoRemainingOnboardCountries, TransitImportCountries, TransitExportCountries, 

| countryEventTypes 
|  
| List  of <<string>> 
| If this is a country subscription, the list of event types that the country should receive
|  

| port 
|  
| String  
| If this is a port subscription, the 5-character port code for the subscription.
|  

| portRole 
|  
| String  
| If this is a port subscription, the role the port must play in the transport plan of a consignment or container transport to receive events
|  _Enum:_ TransshipmentPorts, EntryPort, ExitPort, 

| portEventTypes 
|  
| List  of <<string>> 
| If this is a port subscription, the list of event types that the port should receive
|  

| orgEventTypes 
|  
| List  of <<string>> 
| An array of event types. The subscription will only receive events whose type is in this list
|  

| docEventFilters 
|  
| List  of <<DocEventFilter>> 
| An array of document event filters. The subscription will only receive document events whose type and action match an entry in this list
|  

| ports 
|  
| List  of <<string>> 
| If this is a province subscription, the array of ports for which the subscription should receive events. Otherwise null. Each entry should be a 5-character UN/Locode of a port
|  

| provinceEventTypes 
|  
| List  of <<string>> 
| An array of event types. The subscription will only receive events whose type is in this list
|  

| subscribedOrg 
|  
| String  
| If this is an org subscription, the ID of the organization 
|  

| terminal 
|  
| String  
| If this is a terminal subscription, the 5-character port code for the subscription followed by suffix to specify a specific terminal code.
|  

|===


[#TerminalSubscription]
=== _TerminalSubscription_ 



[.fields-TerminalSubscription]
[cols="2,1,2,4,1"]
|===         
| Field Name| Required| Type| Description| Format

| terminal 
| X 
| String  
| The identifier of the terminal.
|  

| webhook 
| X 
| Webhook  
| 
|  

| name 
|  
| String  
| The name to be associated with this subscription
|  

|===


[#Webhook]
=== _Webhook_ 



[.fields-Webhook]
[cols="2,1,2,4,1"]
|===         
| Field Name| Required| Type| Description| Format

| sharedSecret 
|  
| String  
| In order for applications to validate the authenticity of events, events can be optionally signed by this key. If null, the event will not be signed
|  

| uri 
| X 
| String  
| The uri to call for each event. Events will be sent to the uri using a HTTP POST request, which the uri must promptly (within 5 seconds) answer with an HTTP success code response
|  

|===


[#WebhookStatus]
=== _WebhookStatus_ 



[.fields-WebhookStatus]
[cols="2,1,2,4,1"]
|===         
| Field Name| Required| Type| Description| Format

| webhook 
| X 
| String  
| Webhook URI
|  

| webhookStatus 
| X 
| String  
| Status of the subscription&#39;s webhook. ENABLED means that events are being published to the webhook as normal. DISABLED means that SIP will not attempt to publish events to this webhook. Instead, those events will be saved and published to the webhook after we detect that it is healthy
|  _Enum:_ ENABLED, DISABLED, 

| disableStartTime 
|  
| Long  
| Time that the webhook was most recently disabled as epoch time in ms
| int64 

| disableEndTime 
|  
| Long  
| Time that the webhook will automatically be enabled, as epoch time in ms
| int64 

| mostRecentFailureTime 
|  
| Long  
| Most recent time that the webhook failed, meaning it returned an error response or timed out, as epoch time in ms. Repeated failures over time result in SIP disabling the webhook
| int64 

| disableStartTimeHumanReadable 
|  
| String  
| Time in UTC that the webhook was most recently disabled
|  

| disableEndTimeHumanReadable 
|  
| String  
| Time in UTC that the webhook will automatically be enabled
|  

| mostRecentFailureTimeHumanReadable 
|  
| String  
| Most recent time in UTC that the webhook failed, meaning it returned an error response or timed out. Repeated failures over time result in SIP disabling the webhook
|  

|===


[#WebhookTestResult]
=== _WebhookTestResult_ 



[.fields-WebhookTestResult]
[cols="2,1,2,4,1"]
|===         
| Field Name| Required| Type| Description| Format

| requestBody 
|  
| String  
| 
|  

| requestHeaders 
|  
| String  
| 
|  

| responseTime 
|  
| Long  
| 
| int64 

| result 
|  
| String  
| 
|  _Enum:_ PASSED, FAILED, 

| statusCode 
|  
| Integer  
| 
| int32 

| testResultDetails 
|  
| String  
| 
|  

| yourResponse 
|  
| String  
| 
|  

|===


